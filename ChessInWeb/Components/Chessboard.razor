@using ChessInWeb.Hubs;
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.AspNetCore.Identity;
@inject AuthenticationStateProvider GetAuthenticationStateAsync
@inject NavigationManager NavManager
@implements IDisposable
<div class="chessboard" disabled="@isDisabled">
    <div class="squares">
    @for (int i = 63; i >= 0; i--)
    {
        int s = i - j;
        <Square @bind-Rerender="@rerenderCount" IconSrc="@IconSrc(s)" IdNum="@s" Selected="@availableSquares.Contains(s)" HandleClick="@ManageClick"></Square>
        j -= 2;
        if (j < -7)
        {
            j = 7;
        }
    }
    </div>
    <Informer WhiteSided=true TimeRanOut="@TimeRanOut" @bind-Message="informerMessage" @ref=informer
              TimeControl="@GameObj.TimeControl" Increment="@GameObj.Increment"></Informer>
</div>
@code {
    [Parameter]
    public Game GameObj { get; set; }
    private string informerMessage = "Message from chessboard";
    private string userId;
    private int rerenderCount = 0;
    private HashSet<int> availableSquares = new();
    private int currentSelected = -1;
    private int j = 7;
    private bool isDisabled = false;
    private Informer informer;
    private HubConnection? hubConnection;
    protected override async Task OnInitializedAsync()
    {
        GameObj.GameManager?.GetMoves();
        informerMessage = GameObj.GameManager?.ReturnGameState();
        hubConnection = new HubConnectionBuilder()
        .WithUrl(NavManager.ToAbsoluteUri("/chessmoveshub"))
        .WithAutomaticReconnect()
        .Build();
        var authState = await GetAuthenticationStateAsync.GetAuthenticationStateAsync();
        
        // ChessMovesHub.AddUserToGame()

        hubConnection.On<Move>("ReceiveMessage", (move) =>
        {
            GameObj.GameManager.MakeMove(move);
            InvokeAsync(StateHasChanged);
        });

        await hubConnection.StartAsync();
    }
    private string resources = "/Icons/";
    private string IconSrc(int square)
    {
        string respond = "";
        switch (Piece.PieceType(GameObj.GameManager.Squares[square]))
        {
            case 1:
                respond = "king";
                break;
            case 2:
                respond = "pawn";
                break;
            case 3:
                respond = "knight";
                break;
            case 5:
                respond = "bishop";
                break;
            case 6:
                respond = "rook";
                break;
            case 7:
                respond = "queen";
                break;
            default:
                return "";
        }
        string color = Piece.Colour(GameObj.GameManager.Squares[square]) == 8 ? "white" : "black";
        return resources + color + respond + ".png";
    }
    public void ManageClick(int id)
    {
        if (availableSquares.Contains(id))
        {
            GameObj.GameManager.MakeMove(GameObj.GameManager.MovesStorage[currentSelected].Where(x => x.EndIndex == id).First());
            CheckGameFinished();
            ClearMeta();
            GameObj.GameManager.GetMoves();
            StateHasChanged();
            informer.SwitchTimer();
            informerMessage = GameObj.GameManager.ReturnGameState();
            return;
        }
        ClearMeta();
        if (GameObj.GameManager.Squares[id] != Piece.None && GameObj.GameManager.MovesStorage.ContainsKey(id))
        {
            currentSelected = id;
            GameObj.GameManager.MovesStorage[id].Select(x => x.EndIndex).ToList().ForEach(x => availableSquares.Add(x));
            StateHasChanged();
            return;
        }
    }
    private void ClearMeta()
    {
        rerenderCount++;
        currentSelected = -1;
        availableSquares.Clear();
    }
    private void CheckGameFinished()
    {

    }
    public void TimeRanOut(bool white)
    {
        isDisabled = true;
        informer.StopTimers();
    }
    public void Dispose()
    {
        
    }
}
